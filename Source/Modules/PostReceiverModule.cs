using System;
using System.Threading;
using System.Collections.Generic;

using RedditSharp;
using RedditSharp.Things;

namespace HFYBot.Modules
{
	/// <summary>
	/// Module that deals with new posts on the subreddit.
	/// </summary>
	public class PostReceiverModule : RedditModule
	{
		/// <summary>
		/// The thread on which the module operates.
		/// </summary>
		Thread thread;

		/// <summary>
		/// Internal flag to tell whether the module should be enabled. Allows module to finish a pass before stopping. 
		/// </summary>
		private bool enabled = false;

		/// <summary>
		/// The time to wait between passes
		/// </summary>
		TimeSpan waitTime = new TimeSpan (0, 5, 0);


		/// <summary>
		/// Initializes a new instance of the <see cref="HFYBot.Modules.PostReceiverModule"/> class.
		/// </summary>
		/// <param name="reddit">Reddit API instance</param>
		/// <param name="sub">Target subreddit</param>
		public PostReceiverModule (Reddit reddit, Subreddit sub) :base("post receiver", reddit, sub)
		{
			thread = new Thread(new ThreadStart(run));
			state = ModuleState.Diabled;
		}

		/// <summary>
		/// Make a pass through a number of new posts
		/// </summary>
		/// <param name="postCount">The number of posts to check</param>
		void MakePass(int postCount){

			//TODO: Optimise post receiveing code. 
			try{
				List<RedditUser> pendingEdits = new List<RedditUser>(0);

				List<Post> posts = (List<Post>)sub.New.GetListing(postCount);
				foreach(Post post in posts){
					if(isOC(post) && !processed(post)){
						if(!pendingEdits.Contains(post.Author)) pendingEdits.Add(post.Author);
						post.Comment("Please wait...");
					}
				}

				foreach(RedditUser user in pendingEdits){
					string comment = generateCommentText(user);
					foreach(Post post in user.Posts){
						if(isOC(post)){
							foreach(Comment comm in post.Comments)
								if(comm.Author.Equals(reddit.User.Name))
									comm.EditText(comment);
						}
					}
				}

			} catch (System.Net.WebException) {
				state = ModuleState.Crashed;
				enabled = false;
				//TODO: automatically restart module upon crash.
			}
		}

		/// <summary>
		/// Generates the comment text.
		/// </summary>
		/// <returns>The comment text.</returns>
		/// <param name="user">User to generate text for.</param>
		string generateCommentText(RedditUser user){
			int count = 0;
			List<Post> availiblePosts = new List<Post>(0);
			foreach (Post post in user.Posts) {
				if (post.Subreddit.Equals (sub) && isOC (post)) {
					if (availiblePosts.Count < 25)
						availiblePosts.Add (post);
					count++;
				}
			}

			string comm;

			if (count > 1) {
				comm = "There are " + count.ToString () + " stories by [u/" + user.Name + "](http://reddit.com/u/" + user.Name + ") Including:";
				foreach (Post p in availiblePosts) {
					comm += "\n\n* [" + p.Title + "](" + p.Url + ")";
				}
			} else {
				comm = "There are no other stories by [u/" + user.Name + "](http://reddit.com/u/" + user.Name+ ")";
			}

			comm += "\n\nThis list was automatically generated by HFYBotReborn version "
				+ Program.version
				+". Please contact /u/KaiserMagnus if you have any queries. This bot is [open source]((https://github.com/waitingtocompile/HFYBotReborn).";
			return comm;
		}
		/// <summary>
		/// Checks if post is OC
		/// </summary>
		/// <returns><c>true</c>, if is OC, <c>false</c> otherwise.</returns>
		/// <param name="post">Post to check</param>
		bool isOC(Post post){
			return (post.Title.ToUpperInvariant().Contains("[OC]")|post.LinkFlairText.ToUpperInvariant().Equals("OC"));
		}

		/// <summary>
		/// Checks if post has been processed
		/// </summary>
		/// <param name="post">Post to check</param>
		bool processed(Post post){
			foreach (Comment com in post.Comments) {
				if (com.Author.Equals (reddit.User.Name))
					return true;
			}
			return false;
		}

		/// <summary>
		/// Run this instance. Intended to be started within the thread.
		/// </summary>
		void run()
		{
			state = ModuleState.Enabled;
			MakePass(40);
			while (enabled) {
				state = ModuleState.Idle;
				Thread.Sleep (waitTime);
				state = ModuleState.Enabled;
				MakePass(5);
			}
			state = ModuleState.Diabled;
		}

		/// <summary>
		/// Sets whether the module is enabled. Will wait until the current pass is finished.
		/// </summary>
		/// <param name="b">Intended state.</param>
		public void setEnabled(bool b){
			if (!b && state.Equals (ModuleState.Idle)) {
				thread.Abort ();
				enabled = false;
			} else
				enabled = b;
		}
	}
}

